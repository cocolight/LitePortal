name: Build Native Executables

on:
  push:
    branches: [main, master]
  workflow_dispatch:

jobs:
  pkg:
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: node22-linux-x64
            ext: ''
            artifact_name: server-linux
          - os: macos-latest
            target: node22-macos-x64
            ext: ''
            artifact_name: server-macos
          - os: windows-latest
            target: node22-win-x64
            ext: .exe
            artifact_name: server-windows

    runs-on: ${{ matrix.os }}

    steps:
      # 1. 检出代码
      - name: Checkout
        uses: actions/checkout@v4

      # 2. 安装 pnpm
      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      # 3. 安装 Node.js
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'
          cache-dependency-path: |
            frontend/pnpm-lock.yaml
            backend/pnpm-lock.yaml

      # 4. 清理旧的构建
      - name: Clean previous builds
        run: |
          # 清理 dist 目录
          if [ -d "dist" ]; then rm -rf dist; fi
          # 执行前后端的 clean:build
          cd frontend
          pnpm run clean:build 2>/dev/null || echo "前端 clean:build 不存在，跳过"
          cd ../backend
          pnpm run clean:build 2>/dev/null || echo "后端 clean:build 不存在，跳过"
        shell: bash

      # 5. 创建输出目录结构
      - name: Create output directories
        run: |
          mkdir -p dist/executable
          mkdir -p dist/data
          mkdir -p dist/web
          echo "输出目录创建完成:"
          ls -la dist/
        shell: bash

      # 6. 前端构建
      - name: Frontend install & build
        working-directory: frontend
        run: |
          pnpm install --frozen-lockfile
          pnpm run build
          echo "=== 前端构建目录结构 ==="
          echo "前端构建目录 ($(pwd)/dist):"
          find dist -maxdepth 2 -type f | head -20 || echo "前端 dist 目录不存在"
        shell: bash

      # 7. 复制前端产物到 dist/web
      - name: Copy frontend to dist/web
        run: |
          # 复制前端 dist
          cp -r frontend/dist/* dist/web/
          # 复制 favicon 文件
          for icon in favicon.ico favicon.png favicon.svg; do
            if [ -f "frontend/public/$icon" ]; then
              cp "frontend/public/$icon" "dist/web/$icon"
            fi
          done
        shell: bash

      # 8. 后端构建和编译原生模块
      - name: Backend install & build
        working-directory: backend
        run: |
          pnpm install --frozen-lockfile
          pnpm run build:prod
          # 编译 better-sqlite3 原生模块
          echo "编译 better-sqlite3 原生模块..."
          pnpm rebuild better-sqlite3
          # 验证编译结果
          echo "better-sqlite3 编译结果:"
          find node_modules/better-sqlite3 -name "*.node" 2>/dev/null | head -5 || echo "未找到 .node 文件"
          echo "=== 后端构建目录结构 ==="
          echo "后端构建目录 ($(pwd)/dist):"
          find dist -maxdepth 2 -type f | head -20 || echo "后端 dist 目录不存在"
        shell: bash

      # 9. 准备后端文件到 dist 目录
      - name: Prepare backend files
        run: |
          # 确保 dist 目录存在
          mkdir -p dist
          # 复制后端构建产物
          if [ -d "backend/dist" ]; then
            cp -r backend/dist/* dist/
            echo "后端构建产物复制完成"
          else
            echo "警告: backend/dist 目录不存在"
          fi
          # 复制配置文件
          for file in package.json pnpm-lock.yaml .env.production; do
            if [ -f "backend/$file" ]; then
              cp "backend/$file" "dist/$file"
              echo "已复制 $file"
            else
              echo "警告: backend/$file 文件不存在"
            fi
          done
          # 复制编译好的 better-sqlite3 模块
          echo "复制 better-sqlite3 原生模块..."
          mkdir -p dist/node_modules/better-sqlite3
          if [ -d "backend/node_modules/better-sqlite3" ]; then
            cp -r backend/node_modules/better-sqlite3/* dist/node_modules/better-sqlite3/
            echo "better-sqlite3 复制完成"
          else
            echo "警告: backend/node_modules/better-sqlite3 目录不存在"
          fi

          echo "=== 完整 dist 目录结构 ==="
          echo "根目录下的 dist 结构:"
          find dist -maxdepth 3 -type d | sort
          echo ""
          echo "dist 目录下的文件:"
          find dist -maxdepth 2 -type f | head -30
        shell: bash

      # 10. 安装生产依赖和准备 pkg
      - name: Prepare for pkg packaging
        working-directory: dist
        run: |
          # 安装生产依赖
          pnpm install --production --shamefully-hoist
          # 安装 @yao-pkg/pkg
          pnpm add -D @yao-pkg/pkg

          # 验证 better-sqlite3 是否存在
          echo "验证 better-sqlite3 模块:"
          find node_modules/better-sqlite3 -name "*.node" 2>/dev/null | head -5 || echo "未找到 .node 文件"

          echo "=== 打包前 dist 目录结构 ==="
          echo "当前目录 ($(pwd)) 结构:"
          find . -maxdepth 3 -type d | sort
          echo ""
          echo "重要文件检查:"
          echo "main.js 是否存在: $(test -f "main.js" && echo "是" || echo "否")"
          echo "web 目录是否存在: $(test -d "web" && echo "是" || echo "否")"
          if [ -d "web" ]; then
            echo "web 目录内容:"
            find web -maxdepth 2 -type f | head -20
          fi
        shell: bash

      # 11. 配置 package.json 用于 pkg
      - name: Configure package.json for pkg
        working-directory: dist
        run: |
          # 首先验证 web 目录确实存在且包含文件
          echo "验证 web 目录内容:"
          if [ -d "web" ]; then
            find web -type f | head -10
            echo "web 目录文件总数:"
            find web -type f | wc -l
          else
            echo "错误: web 目录不存在!"
            exit 1
          fi

          # 创建更完整的 pkg 配置
          jq '. + {
            "bin": "main.js",
            "pkg": {
              "targets": ["${{ matrix.target }}"],
              "outputPath": "executable",
              "outputName": "server",
              "assets": [
                "web/**/*",
                "web/**/.*",  # 包含隐藏文件
                ".env.production",
                "node_modules/better-sqlite3/**/*",
                "node_modules/**/*.node"
              ]
            }
          }' package.json > package.json.tmp && mv package.json.tmp package.json

          echo "配置后的 package.json pkg 部分:"
          cat package.json | jq '.pkg'
        shell: bash

      # 12. 使用 @yao-pkg/pkg 打包
      - name: Package with @yao-pkg/pkg
        working-directory: dist
        run: |
          echo "当前目录内容:"
          ls -la
          echo "web 目录详细内容:"
          find web -type f | head -20

          echo "开始打包..."
          # 使用更详细的打包命令和调试模式
          npx @yao-pkg/pkg . --target ${{ matrix.target }} --output executable/server${{ matrix.ext }}

          echo "打包完成，检查生成的文件:"
          ls -lh executable/
        shell: bash

      # 13. 验证可执行文件内容
      - name: Verify executable contents
        run: |
          echo "=== 验证可执行文件内容 ==="
          # 检查文件大小（应该比较大，因为包含前端文件）
          echo "可执行文件大小:"
          ls -lh "dist/executable/server${{ matrix.ext }}"

          # 简单的大小检查：如果文件小于 10MB，可能没有包含前端文件
          FILE_SIZE=$(stat -c%s "dist/executable/server${{ matrix.ext }}" 2>/dev/null || stat -f%z "dist/executable/server${{ matrix.ext }}" 2>/dev/null)
          if [ "$FILE_SIZE" -lt 10000000 ]; then
            echo "警告: 可执行文件可能太小，前端文件可能没有正确打包"
          else
            echo "可执行文件大小正常"
          fi

          # 使用 strings 命令检查可执行文件中是否包含前端文件
          if command -v strings > /dev/null 2>&1; then
            echo "检查可执行文件中是否包含 HTML 文件签名:"
            strings "dist/executable/server${{ matrix.ext }}" | grep -i "DOCTYPE html" | head -3 || echo "未找到 HTML 内容"
            echo "检查可执行文件中是否包含 JavaScript 内容:"
            strings "dist/executable/server${{ matrix.ext }}" | grep -i "script" | head -3 || echo "未找到 JavaScript 内容"
            echo "检查可执行文件中是否包含 web 目录路径:"
            strings "dist/executable/server${{ matrix.ext }}" | grep -E "(/web/|web/)" | head -5 || echo "未找到 web 目录路径"
          else
            echo "strings 命令不可用，跳过内容检查"
          fi
        shell: bash

      # 14. 上传可执行文件产物
      - name: Upload executable artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: dist/executable/server${{ matrix.ext }}
          retention-days: 7